package main

import (
	"fmt"
	"os"
	"recac/internal/gamify"
	"recac/internal/utils"
	"sort"
	"strings"
	"time"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	portfolioUser string
	portfolioOut  string
)

var portfolioCmd = &cobra.Command{
	Use:   "portfolio",
	Short: "Generate a developer portfolio from git history",
	Long: `Generates a professional portfolio document (Markdown) based on your git contribution history.
It analyzes your commits, code impact, languages used, and uses AI to summarize your key achievements.`,
	RunE: runPortfolio,
}

func init() {
	rootCmd.AddCommand(portfolioCmd)
	portfolioCmd.Flags().StringVarP(&portfolioUser, "user", "u", "", "Git user name (defaults to current git user)")
	portfolioCmd.Flags().StringVarP(&portfolioOut, "out", "o", "PORTFOLIO.md", "Output file path")
}

func runPortfolio(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current working directory: %w", err)
	}

	// 1. Determine User
	user := portfolioUser
	if user == "" {
		// Try git config
		out, err := execCommand("git", "config", "user.name").Output()
		if err != nil {
			return fmt.Errorf("failed to determine git user: %w (use --user)", err)
		}
		user = strings.TrimSpace(string(out))
	}
	if user == "" {
		return fmt.Errorf("could not determine user name, please use --user")
	}

	fmt.Fprintf(cmd.OutOrStdout(), "ðŸŽ¨ Generating portfolio for: %s\n", user)

	// 2. Analyze Repo Stats (Gamification)
	fmt.Fprintln(cmd.OutOrStdout(), "ðŸ“Š Analyzing contribution stats...")
	client := gitClientFactory()
	lb, err := gamify.AnalyzeRepo(client, cwd)
	if err != nil {
		return fmt.Errorf("failed to analyze repo: %w", err)
	}

	var stats *gamify.Player
	for _, p := range lb.Players {
		if strings.EqualFold(p.Name, user) {
			stats = p
			break
		}
	}

	if stats == nil {
		return fmt.Errorf("no contributions found for user '%s'", user)
	}

	// 3. Retrieve Recent Commit History for AI Context
	fmt.Fprintln(cmd.OutOrStdout(), "ðŸ“œ Fetching recent commits for summary...")
	// git log --author=<user> --oneline -n 50 --no-merges
	logCmd := execCommand("git", "log", fmt.Sprintf("--author=%s", user), "--oneline", "-n", "50", "--no-merges")
	logOut, err := logCmd.Output()
	if err != nil {
		return fmt.Errorf("failed to fetch git log: %w", err)
	}
	commitLog := string(logOut)

	// 4. Generate Content with AI
	fmt.Fprintln(cmd.OutOrStdout(), "ðŸ¤– Consulting AI agent for achievements...")

	provider := viper.GetString("provider")
	model := viper.GetString("model")
	ag, err := agentClientFactory(ctx, provider, model, cwd, "recac-portfolio")
	if err != nil {
		return fmt.Errorf("failed to create agent: %w", err)
	}

	// Format Languages for Prompt
	var langs []string
	for l, count := range stats.Languages {
		langs = append(langs, fmt.Sprintf("%s (%d lines)", l, count))
	}

	prompt := fmt.Sprintf(`You are a Career Coach and Tech Writer.
Generate a professional portfolio summary and a list of key achievements for a developer named "%s".

Data:
- Total Commits: %d
- Lines Added: %d
- Bug Fixes: %d
- Test Edits: %d
- Doc Edits: %d
- Top Languages: %s

Recent Commit History:
%s

Instructions:
1. Write a "Professional Summary" (2-3 sentences) highlighting their impact and focus.
2. Write "Key Achievements" (bullet points) derived from the commit logs. Synthesize small commits into larger features where possible.
3. Be professional, concise, and impressive.

Return the result as Markdown (without wrapping in code blocks).
Format:
### Professional Summary
...
### Key Achievements
...
`, user, stats.Commits, stats.LinesAdded, stats.BugFixes, stats.TestEdits, stats.DocEdits, strings.Join(langs, ", "), commitLog)

	aiContent, err := ag.Send(ctx, prompt)
	if err != nil {
		return fmt.Errorf("agent failed: %w", err)
	}

	aiContent = utils.CleanCodeBlock(aiContent)

	// 5. Construct Final Markdown
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# Portfolio: %s\n\n", user))
	sb.WriteString(fmt.Sprintf("> Generated by `recac portfolio` on %s\n\n", time.Now().Format("2006-01-02")))

	sb.WriteString("## Stats Overview\n\n")
	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|---|---|\n")
	sb.WriteString(fmt.Sprintf("| ðŸ† XP | %d |\n", stats.XP))
	sb.WriteString(fmt.Sprintf("| ðŸ”¨ Commits | %d |\n", stats.Commits))
	sb.WriteString(fmt.Sprintf("| ðŸ› Bug Fixes | %d |\n", stats.BugFixes))
	sb.WriteString(fmt.Sprintf("| ðŸ“ Lines Added | %d |\n", stats.LinesAdded))
	sb.WriteString("\n")

	if len(stats.Badges) > 0 {
		sb.WriteString("## Badges\n\n")
		for _, b := range stats.Badges {
			sb.WriteString(fmt.Sprintf("- %s\n", b))
		}
		sb.WriteString("\n")
	}

	sb.WriteString("## Languages\n\n")
	// Sort languages by lines
	type langStat struct {
		Name  string
		Lines int
	}
	var sortedLangs []langStat
	for l, c := range stats.Languages {
		sortedLangs = append(sortedLangs, langStat{l, c})
	}
	sort.Slice(sortedLangs, func(i, j int) bool {
		return sortedLangs[i].Lines > sortedLangs[j].Lines
	})

	for _, l := range sortedLangs {
		// Simple ASCII bar
		barLen := l.Lines / 100
		if barLen > 20 {
			barLen = 20
		}
		if barLen < 1 {
			barLen = 1
		}
		bar := strings.Repeat("â–ˆ", barLen)
		sb.WriteString(fmt.Sprintf("- **%s**: %s (%d lines)\n", l.Name, bar, l.Lines))
	}
	sb.WriteString("\n")

	sb.WriteString(aiContent)
	sb.WriteString("\n")

	// 6. Write to File
	if err := os.WriteFile(portfolioOut, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Fprintf(cmd.OutOrStdout(), "âœ… Portfolio saved to %s\n", portfolioOut)

	return nil
}
