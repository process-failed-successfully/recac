package main

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"path/filepath"
	"strings"
	"time"

	"recac/internal/utils"

	"github.com/AlecAivazis/survey/v2"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// QuizQuestion represents a quiz question generated by the agent
type QuizQuestion struct {
	Question    string   `json:"question"`
	Options     []string `json:"options"`
	Correct     string   `json:"correct_answer"` // Should match one of the options
	Explanation string   `json:"explanation"`
}

var quizCmd = &cobra.Command{
	Use:   "quiz [path]",
	Short: "Take a quiz about the codebase",
	Long:  `Generates a multiple-choice question based on a random file in the codebase to help you learn the project.`,
	Args:  cobra.MaximumNArgs(1),
	RunE:  runQuiz,
}

func init() {
	rootCmd.AddCommand(quizCmd)
}

func runQuiz(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current working directory: %w", err)
	}

	targetDir := cwd
	if len(args) > 0 {
		targetDir = args[0]
	}

	fmt.Fprintln(cmd.OutOrStdout(), "ðŸŽ² Finding a file to quiz you on...")

	// 1. Pick a random file
	fileContent, filePath, err := getRandomGoFile(targetDir)
	if err != nil {
		return fmt.Errorf("failed to find a valid Go file: %w", err)
	}

	fmt.Fprintf(cmd.OutOrStdout(), "ðŸ“„ Selected file: %s\n", filePath)
	fmt.Fprintln(cmd.OutOrStdout(), "ðŸ¤– Generating question...")

	// 2. Prepare Agent
	provider := viper.GetString("provider")
	model := viper.GetString("model")
	ag, err := agentClientFactory(ctx, provider, model, cwd, "recac-quiz")
	if err != nil {
		return fmt.Errorf("failed to initialize agent: %w", err)
	}

	// 3. Prompt
	prompt := fmt.Sprintf(`You are a helpful mentor.
Create a challenging multiple-choice question based on the following Go code.
The question should test understanding of the code's purpose, logic, complexity, or potential issues.
Do not ask trivial questions like "what is the package name?".

Code:
%s

Return the result as a raw JSON object with the following structure:
{
    "question": "The question text",
    "options": ["Option A", "Option B", "Option C", "Option D"],
    "correct_answer": "The correct option text (must be exact match)",
    "explanation": "Explanation of why it is correct"
}

Do not wrap the JSON in markdown code blocks. Just return the raw JSON string.`, fileContent)

	// 4. Send to Agent
	resp, err := ag.Send(ctx, prompt)
	if err != nil {
		return fmt.Errorf("agent failed to generate quiz: %w", err)
	}

	// 5. Parse Response
	jsonStr := utils.CleanJSONBlock(resp)
	var q QuizQuestion
	if err := json.Unmarshal([]byte(jsonStr), &q); err != nil {
		return fmt.Errorf("failed to parse quiz response: %w\nRaw: %s", err, resp)
	}

	// 6. Ask Question
	var answer string
	promptSurvey := &survey.Select{
		Message: q.Question,
		Options: q.Options,
	}

	if err := askOneFunc(promptSurvey, &answer); err != nil {
		return err // Handle ctrl-c etc
	}

	// 7. Check Answer
	if answer == q.Correct {
		fmt.Fprintln(cmd.OutOrStdout(), "\nâœ… Correct!")
	} else {
		fmt.Fprintf(cmd.OutOrStdout(), "\nâŒ Incorrect. The correct answer was: %s\n", q.Correct)
	}
	fmt.Fprintf(cmd.OutOrStdout(), "\nðŸ’¡ %s\n", q.Explanation)

	return nil
}

func getRandomGoFile(root string) (string, string, error) {
	var files []string

	// Basic ignore list
	ignoreMap := map[string]bool{
		".git":         true,
		"vendor":       true,
		"node_modules": true,
		".recac":       true,
	}

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			if ignoreMap[info.Name()] {
				return filepath.SkipDir
			}
			return nil
		}
		if strings.HasSuffix(info.Name(), ".go") && !strings.HasSuffix(info.Name(), "_test.go") {
			files = append(files, path)
		}
		return nil
	})

	if err != nil {
		return "", "", err
	}

	if len(files) == 0 {
		return "", "", fmt.Errorf("no .go files found in %s", root)
	}

	// Seed random
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	selectedPath := files[r.Intn(len(files))]

	content, err := os.ReadFile(selectedPath)
	if err != nil {
		return "", "", err
	}

	// Limit content size to avoid context limits (e.g. 5KB)
	const maxSize = 5000
	strContent := string(content)
	if len(strContent) > maxSize {
		strContent = strContent[:maxSize] + "\n... (truncated)"
	}

	// Return relative path for display
	if rel, err := filepath.Rel(root, selectedPath); err == nil {
		selectedPath = rel
	}

	return strContent, selectedPath, nil
}
