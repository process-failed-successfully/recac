package main

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// execCommand allows mocking in tests
// var execCommand = exec.Command (defined in resume.go or shared)

var (
	profileAnalyzeFile string
	profileOutput      string
)

var profileCmd = &cobra.Command{
	Use:   "profile [command]",
	Short: "Profile a Go command and analyze performance with AI",
	Long: `Executes a Go command (e.g., 'go test ./...') with CPU profiling enabled,
or analyzes an existing profile file. The output is parsed and sent to the
configured AI agent to identify bottlenecks and suggest optimizations.

Examples:
  recac profile "go test ./internal/..."
  recac profile --analyze cpu.prof`,
	Args: cobra.ArbitraryArgs,
	RunE: runProfile,
}

func init() {
	rootCmd.AddCommand(profileCmd)
	profileCmd.Flags().StringVarP(&profileAnalyzeFile, "analyze", "a", "", "Analyze an existing profile file")
	profileCmd.Flags().StringVarP(&profileOutput, "output", "o", "cpu.prof", "Output file for the profile (when running a command)")
}

func runProfile(cmd *cobra.Command, args []string) error {
	ctx := cmd.Context()
	cwd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("failed to get current working directory: %w", err)
	}

	var profilePath string

	// Mode 1: Analyze existing file
	if profileAnalyzeFile != "" {
		profilePath = profileAnalyzeFile
		if _, err := os.Stat(profilePath); os.IsNotExist(err) {
			return fmt.Errorf("profile file '%s' not found", profilePath)
		}
		fmt.Fprintf(cmd.OutOrStdout(), "Analyzing existing profile: %s\n", profilePath)
	} else {
		// Mode 2: Run command and generate profile
		if len(args) == 0 {
			return fmt.Errorf("please provide a command to profile or use --analyze")
		}

		// Check if it's a 'go test' command to inject flags
		commandParts := args
		// If user passed a single string arg like "go test ./...", split it
		if len(args) == 1 && strings.Contains(args[0], " ") {
			commandParts = strings.Fields(args[0])
		}

		profilePath = profileOutput

		// Inject -cpuprofile if it's a go test command
		if len(commandParts) > 1 && commandParts[0] == "go" && commandParts[1] == "test" {
			// Check if -cpuprofile is already present
			hasProfileFlag := false
			for _, arg := range commandParts {
				if strings.Contains(arg, "-cpuprofile") {
					hasProfileFlag = true
					break
				}
			}

			if !hasProfileFlag {
				// Inject it before the packages (simplified: just append to flags before targets?)
				// 'go test' arguments order matters. flags should be before packages usually, but go handles mixed.
				// safer to append.
				commandParts = append(commandParts, fmt.Sprintf("-cpuprofile=%s", profilePath))
				fmt.Fprintf(cmd.OutOrStdout(), "Injected CPU profile flag: -cpuprofile=%s\n", profilePath)
			}
		} else {
			fmt.Fprintln(cmd.OutOrStdout(), "‚ö†Ô∏è  Command is not detected as 'go test'. Assuming it will generate a profile at the expected path.")
			fmt.Fprintf(cmd.OutOrStdout(), "Expected profile output: %s\n", profilePath)
		}

		// Run the command
		fmt.Printf("Running: %s\n", strings.Join(commandParts, " "))
		runCmd := execCommand(commandParts[0], commandParts[1:]...)
		runCmd.Stdout = cmd.OutOrStdout()
		runCmd.Stderr = cmd.ErrOrStderr()

		if err := runCmd.Run(); err != nil {
			return fmt.Errorf("command failed: %w", err)
		}

		// Verify profile was created
		if _, err := os.Stat(profilePath); os.IsNotExist(err) {
			return fmt.Errorf("profile file '%s' was not generated by the command", profilePath)
		}
		fmt.Fprintf(cmd.OutOrStdout(), "Profile generated successfully at %s\n", profilePath)
	}

	// Analyze the profile
	return analyzeProfile(ctx, cmd, cwd, profilePath)
}

func analyzeProfile(ctx context.Context, cmd *cobra.Command, cwd, profilePath string) error {
	// Use 'go tool pprof' to get text output
	// go tool pprof -top -cum <file>
	pprofCmd := execCommand("go", "tool", "pprof", "-top", "-cum", profilePath)
	var outBuf bytes.Buffer
	pprofCmd.Stdout = &outBuf
	pprofCmd.Stderr = cmd.ErrOrStderr()

	fmt.Fprintln(cmd.OutOrStdout(), "Parsing profile data...")
	if err := pprofCmd.Run(); err != nil {
		return fmt.Errorf("failed to run 'go tool pprof': %w", err)
	}

	pprofOutput := outBuf.String()
	if len(pprofOutput) == 0 {
		return fmt.Errorf("pprof output is empty")
	}

	// Send to AI Agent
	provider := viper.GetString("provider")
	model := viper.GetString("model")
	ag, err := agentClientFactory(ctx, provider, model, cwd, "recac-profile")
	if err != nil {
		return fmt.Errorf("failed to create agent: %w", err)
	}

	prompt := fmt.Sprintf(`Analyze the following Go CPU profile output (pprof -top -cum).
Identify the top performance bottlenecks.
Suggest specific optimizations or areas to investigate in the code.
Focus on the functions that consume the most cumulative time (cum) but also check flat time.

Profile Output:
'''
%s
'''`, pprofOutput)

	fmt.Fprintln(cmd.OutOrStdout(), "ü§ñ Consulting AI agent for performance analysis...")
	fmt.Println("")

	_, err = ag.SendStream(ctx, prompt, func(chunk string) {
		fmt.Fprint(cmd.OutOrStdout(), chunk)
	})
	fmt.Println("")

	return err
}
