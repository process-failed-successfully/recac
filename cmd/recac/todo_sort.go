package main

import (
	"fmt"
	"sort"
	"strings"

	"github.com/spf13/cobra"
)

var todoSortCmd = &cobra.Command{
	Use:   "sort",
	Short: "Sort tasks in TODO.md by priority",
	Long:  `Sorts tasks in TODO.md. Pending tasks appear first, sorted by priority (FIXME/BUG > TODO > NOTE). Done tasks are moved to the bottom.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		return sortTasks(cmd)
	},
}

func init() {
	todoCmd.AddCommand(todoSortCmd)
}

type ParsedTask struct {
	Original  string
	IsDone    bool
	Priority  int // Higher is better
	CleanText string
}

func sortTasks(cmd *cobra.Command) error {
	if err := ensureTodoFile(); err != nil {
		return err
	}

	lines, err := readLines(todoFile)
	if err != nil {
		return err
	}

	var pending []ParsedTask
	var done []ParsedTask
	var header []string

	// Helper to calculate priority
	getPriority := func(text string) int {
		upper := strings.ToUpper(text)
		if strings.Contains(upper, "FIXME") || strings.Contains(upper, "BUG") || strings.Contains(upper, "CRITICAL") || strings.Contains(upper, "URGENT") {
			return 100
		}
		if strings.Contains(upper, "TODO") {
			return 50
		}
		if strings.Contains(upper, "HACK") || strings.Contains(upper, "OPTIMIZE") {
			return 20
		}
		if strings.Contains(upper, "NOTE") || strings.Contains(upper, "INFO") {
			return 10
		}
		return 0
	}

	// Simple parser: Assumes standard format generated by this tool.
	// Preserves the Header lines (lines before the first task or lines starting with #)
	// But strictly speaking, we want to capture everything that isn't a task line?
	// If we do that, we risk moving random text to the top.
	// Let's just keep lines starting with '#' as header, and ignore empty lines, regeneration will add clean spacing.

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "- [ ]") {
			content := strings.TrimPrefix(trimmed, "- [ ]")
			pending = append(pending, ParsedTask{
				Original:  line,
				IsDone:    false,
				Priority:  getPriority(content),
				CleanText: content,
			})
		} else if strings.HasPrefix(trimmed, "- [x]") {
			content := strings.TrimPrefix(trimmed, "- [x]")
			done = append(done, ParsedTask{
				Original:  line,
				IsDone:    true,
				Priority:  getPriority(content),
				CleanText: content,
			})
		} else {
			if strings.HasPrefix(trimmed, "#") {
				header = append(header, line)
			}
		}
	}

	// Sort Pending
	sort.SliceStable(pending, func(i, j int) bool {
		return pending[i].Priority > pending[j].Priority
	})

	// Sort Done
	sort.SliceStable(done, func(i, j int) bool {
		return done[i].Priority > done[j].Priority
	})

	// Reconstruct
	var newLines []string
	if len(header) > 0 {
		newLines = append(newLines, header...)
		newLines = append(newLines, "") // Spacer
	} else {
		newLines = append(newLines, "# TODO", "")
	}

	for _, t := range pending {
		newLines = append(newLines, t.Original)
	}

	if len(done) > 0 {
		// Optional: Add a separator for done tasks?
		// newLines = append(newLines, "", "## Completed") // Might change format too much
		for _, t := range done {
			newLines = append(newLines, t.Original)
		}
	}

	if err := writeLines(todoFile, newLines); err != nil {
		return err
	}

	fmt.Fprintf(cmd.OutOrStdout(), "Sorted %d pending and %d done tasks.\n", len(pending), len(done))
	return nil
}
