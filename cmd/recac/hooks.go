package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
)

var (
	hookProfile string
	hookForce   bool
)

var hooksCmd = &cobra.Command{
	Use:   "hooks",
	Short: "Manage git hooks",
	Long:  `Manage git hooks to enforce code quality and security checks before committing.`,
}

var hooksInstallCmd = &cobra.Command{
	Use:   "install",
	Short: "Install the pre-commit hook",
	Long: `Installs a git pre-commit hook that runs recac checks.
Available profiles:
- default: Runs security check and audit (min score 60).
- strict: Runs security check (fail on any) and audit (min score 80).
- fast: Runs only security check.`,
	RunE: runHooksInstall,
}

var hooksUninstallCmd = &cobra.Command{
	Use:   "uninstall",
	Short: "Uninstall the pre-commit hook",
	RunE:  runHooksUninstall,
}

func init() {
	rootCmd.AddCommand(hooksCmd)
	hooksCmd.AddCommand(hooksInstallCmd)
	hooksCmd.AddCommand(hooksUninstallCmd)

	hooksInstallCmd.Flags().StringVarP(&hookProfile, "profile", "p", "default", "Hook profile (default, strict, fast)")
	hooksInstallCmd.Flags().BoolVarP(&hookForce, "force", "f", false, "Overwrite existing hook")
}

func runHooksInstall(cmd *cobra.Command, args []string) error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}

	// Use hookForce and hookProfile from flags
	return installHooks(cwd, hookProfile, hookForce, cmd.OutOrStdout())
}

func installHooks(cwd, profile string, force bool, out io.Writer) error {
	gitDir := filepath.Join(cwd, ".git")
	if _, err := os.Stat(gitDir); os.IsNotExist(err) {
		return fmt.Errorf("not a git repository (or .git directory not found)")
	}

	hooksDir := filepath.Join(gitDir, "hooks")
	if err := os.MkdirAll(hooksDir, 0755); err != nil {
		return fmt.Errorf("failed to create hooks directory: %w", err)
	}

	hookPath := filepath.Join(hooksDir, "pre-commit")

	if _, err := os.Stat(hookPath); err == nil && !force {
		return fmt.Errorf("pre-commit hook already exists. Use --force to overwrite")
	}

	binPath, err := os.Executable()
	if err != nil {
		// Fallback to expecting 'recac' in PATH
		binPath = "recac"
	}

	script := generateHookScript(binPath, profile)

	if err := os.WriteFile(hookPath, []byte(script), 0755); err != nil {
		return fmt.Errorf("failed to write hook file: %w", err)
	}

	fmt.Fprintf(out, "‚úÖ Pre-commit hook installed (%s profile)\n", profile)
	return nil
}

func runHooksUninstall(cmd *cobra.Command, args []string) error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}

	hookPath := filepath.Join(cwd, ".git", "hooks", "pre-commit")

	if _, err := os.Stat(hookPath); os.IsNotExist(err) {
		fmt.Println("No pre-commit hook found.")
		return nil
	}

	if err := os.Remove(hookPath); err != nil {
		return fmt.Errorf("failed to remove hook: %w", err)
	}

	fmt.Println("‚úÖ Pre-commit hook uninstalled")
	return nil
}

func generateHookScript(binPath, profile string) string {
	var checks []string

	// Basic script structure
	script := []string{
		"#!/bin/sh",
		"# Generated by recac hooks",
		"",
		fmt.Sprintf("RECAC_BIN=%q", binPath),
		"",
		"echo \"üîç Running recac pre-commit checks...\"",
		"",
	}

	switch profile {
	case "strict":
		checks = []string{
			`$RECAC_BIN security --fail`,
			`$RECAC_BIN audit --fail --min-score 80`,
		}
	case "fast":
		checks = []string{
			`$RECAC_BIN security --fail`,
		}
	default: // default
		checks = []string{
			`$RECAC_BIN security`,
			`$RECAC_BIN audit --fail --min-score 60`,
		}
	}

	for _, check := range checks {
		script = append(script, fmt.Sprintf("%s\nif [ $? -ne 0 ]; then\n  echo \"‚ùå Check failed: %s\"\n  exit 1\nfi", check, strings.ReplaceAll(check, "\"", "\\\"")))
	}

	script = append(script, "", "echo \"‚úÖ All checks passed!\"", "exit 0")

	return strings.Join(script, "\n")
}
