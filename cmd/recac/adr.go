package main

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"text/tabwriter"
	"time"

	"recac/internal/utils"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	adrTitle  string
	adrStatus string
)

var adrCmd = &cobra.Command{
	Use:   "adr",
	Short: "Manage Architecture Decision Records (ADRs)",
	Long:  `Create, list, and generate Architecture Decision Records (ADRs) to document significant architectural decisions.`,
}

var adrInitCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize the docs/adr directory",
	RunE:  runAdrInit,
}

var adrNewCmd = &cobra.Command{
	Use:   "new [title]",
	Short: "Create a new ADR",
	Args:  cobra.MinimumNArgs(1),
	RunE:  runAdrNew,
}

var adrListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all ADRs",
	RunE:  runAdrList,
}

var adrGenerateCmd = &cobra.Command{
	Use:   "generate [prompt]",
	Short: "Generate an ADR using AI",
	Long:  `Drafts an ADR based on a prompt using the configured AI agent.`,
	Args:  cobra.MinimumNArgs(1),
	RunE:  runAdrGenerate,
}

func init() {
	rootCmd.AddCommand(adrCmd)
	adrCmd.AddCommand(adrInitCmd)
	adrCmd.AddCommand(adrNewCmd)
	adrCmd.AddCommand(adrListCmd)
	adrCmd.AddCommand(adrGenerateCmd)

	adrNewCmd.Flags().StringVarP(&adrStatus, "status", "s", "Proposed", "Status of the ADR (Proposed, Accepted, Rejected, Deprecated)")
	adrGenerateCmd.Flags().StringVarP(&adrStatus, "status", "s", "Proposed", "Status of the ADR (Proposed, Accepted, Rejected, Deprecated)")
}

func getAdrDir() (string, error) {
	cwd, err := os.Getwd()
	if err != nil {
		return "", err
	}
	return filepath.Join(cwd, "docs", "adr"), nil
}

func runAdrInit(cmd *cobra.Command, args []string) error {
	adrDir, err := getAdrDir()
	if err != nil {
		return err
	}

	if err := os.MkdirAll(adrDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", adrDir, err)
	}

	// Create 0000-use-adrs.md
	initFile := filepath.Join(adrDir, "0000-use-adrs.md")
	if _, err := os.Stat(initFile); err == nil {
		fmt.Printf("ADR directory already initialized at %s\n", adrDir)
		return nil
	}

	content := `# 0. Use Architecture Decision Records

Date: ` + time.Now().Format("2006-01-02") + `

## Status

Accepted

## Context

We need to record architectural decisions.

## Decision

We will use Architecture Decision Records, as described by Michael Nygard in this article: http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions

## Consequences

See Michael Nygard's article, linked above.
`
	if err := os.WriteFile(initFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write init file: %w", err)
	}

	fmt.Printf("Initialized ADRs at %s\n", adrDir)
	return nil
}

func runAdrNew(cmd *cobra.Command, args []string) error {
	title := strings.Join(args, " ")
	return createAdr(title, adrStatus, "")
}

func createAdr(title, status, content string) error {
	adrDir, err := getAdrDir()
	if err != nil {
		return err
	}

	if _, err := os.Stat(adrDir); os.IsNotExist(err) {
		return fmt.Errorf("ADR directory %s does not exist. Run 'recac adr init' first.", adrDir)
	}

	// Find next ID
	files, err := os.ReadDir(adrDir)
	if err != nil {
		return err
	}

	maxID := 0
	re := regexp.MustCompile(`^(\d{4})-`)

	for _, f := range files {
		if f.IsDir() {
			continue
		}
		matches := re.FindStringSubmatch(f.Name())
		if len(matches) > 1 {
			id, _ := strconv.Atoi(matches[1])
			if id > maxID {
				maxID = id
			}
		}
	}

	nextID := maxID + 1
	slug := strings.ToLower(title)
	slug = strings.ReplaceAll(slug, " ", "-")
	reg := regexp.MustCompile(`[^a-z0-9\-]`)
	slug = reg.ReplaceAllString(slug, "")
	if len(slug) > 50 {
		slug = slug[:50]
	}

	filename := fmt.Sprintf("%04d-%s.md", nextID, slug)
	fullPath := filepath.Join(adrDir, filename)

	if content == "" {
		content = fmt.Sprintf(`# %d. %s

Date: %s

## Status

%s

## Context

The issue that we are seeing is...

## Decision

We have decided to...

## Consequences

Positive:
* ...

Negative:
* ...
`, nextID, title, time.Now().Format("2006-01-02"), status)
	} else {
        // Ensure the header has the correct ID and Title if generated by AI
        // Often AI returns just the content, so let's try to prepend/fix if needed
        // For now, assume AI output is the full body.
        // But we should inject the date and status if missing?
        // Let's trust the generated content but maybe prepend the ID if missing.
        if !strings.Contains(content, fmt.Sprintf("# %d.", nextID)) {
             content = fmt.Sprintf("# %d. %s\n\nDate: %s\n\n## Status\n\n%s\n\n%s", nextID, title, time.Now().Format("2006-01-02"), status, content)
        }
    }

	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write ADR: %w", err)
	}

	fmt.Printf("Created ADR: %s\n", fullPath)
	return nil
}

func runAdrList(cmd *cobra.Command, args []string) error {
	adrDir, err := getAdrDir()
	if err != nil {
		return err
	}

	files, err := os.ReadDir(adrDir)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Println("No ADRs found. Run 'recac adr init' first.")
			return nil
		}
		return err
	}

	w := tabwriter.NewWriter(cmd.OutOrStdout(), 0, 0, 3, ' ', 0)
	fmt.Fprintln(w, "FILE\tTITLE\tSTATUS")

	for _, f := range files {
		if f.IsDir() || filepath.Ext(f.Name()) != ".md" {
			continue
		}

		content, err := os.ReadFile(filepath.Join(adrDir, f.Name()))
		if err != nil {
			continue
		}

		lines := strings.Split(string(content), "\n")
		title := "Unknown"
		status := "Unknown"

		for _, line := range lines {
			if strings.HasPrefix(line, "# ") && title == "Unknown" {
				title = strings.TrimPrefix(line, "# ")
			}
			// Simple status check - assumes "Accepted" or similar is on its own line after "## Status"
			// A better way is to scan for the Status section.
		}

        // Scan for status more robustly
        statusRegex := regexp.MustCompile(`(?i)##\s+Status\s*\n+\s*(\w+)`)
        matches := statusRegex.FindStringSubmatch(string(content))
        if len(matches) > 1 {
            status = matches[1]
        }

		fmt.Fprintf(w, "%s\t%s\t%s\n", f.Name(), title, status)
	}
	w.Flush()
	return nil
}

func runAdrGenerate(cmd *cobra.Command, args []string) error {
	promptText := strings.Join(args, " ")

    // Optional: Include codebase context?
    // For now, let's keep it simple and just use the user prompt.
    // Ideally we would optionally scan relevant files.

	ctx := context.Background()
	provider := viper.GetString("provider")
	model := viper.GetString("model")
	cwd, err := os.Getwd()
    if err != nil {
        return err
    }

	ag, err := agentClientFactory(ctx, provider, model, cwd, "recac-adr")
	if err != nil {
		return fmt.Errorf("failed to create agent: %w", err)
	}

    fullPrompt := fmt.Sprintf(`You are a software architect.
Draft an Architecture Decision Record (ADR) based on the following request.
Use the standard ADR format (Context, Decision, Consequences).
Do not include the Title header (starting with #), it will be added automatically.
Start directly with "## Context".

Request: %s`, promptText)

	fmt.Printf("ðŸ¤– Drafting ADR for: %s...\n", promptText)
	resp, err := ag.Send(ctx, fullPrompt)
	if err != nil {
		return err
	}

    cleaned := utils.CleanCodeBlock(resp)

    // Ask to save
    fmt.Println("\nDraft Content:")
    fmt.Println("------------------------------------------------")
    fmt.Println(cleaned)
    fmt.Println("------------------------------------------------")

    fmt.Print("Save this ADR? [y/N]: ")
    var confirm string
    fmt.Scanln(&confirm)

    if strings.ToLower(confirm) == "y" {
        return createAdr(promptText, adrStatus, cleaned)
    }

    fmt.Println("Aborted.")
	return nil
}
