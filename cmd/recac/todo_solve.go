package main

import (
	"context"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"

	"recac/internal/utils"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var todoSolveCmd = &cobra.Command{
	Use:   "solve [index]",
	Short: "Implement a TODO item using AI",
	Long:  `Reads a TODO item from TODO.md (populated by 'recac todo scan'), analyzes the code context, and uses the AI agent to implement the solution.`,
	Args:  cobra.ExactArgs(1),
	RunE:  runTodoSolve,
}

func init() {
	todoCmd.AddCommand(todoSolveCmd)
}

func runTodoSolve(cmd *cobra.Command, args []string) error {
	index, err := strconv.Atoi(args[0])
	if err != nil {
		return fmt.Errorf("invalid index: %s", args[0])
	}

	// 1. Read task from TODO.md
	if err := ensureTodoFile(); err != nil {
		return err
	}

	lines, err := readLines(todoFile)
	if err != nil {
		return fmt.Errorf("failed to read %s: %w", todoFile, err)
	}

	var taskLine string
	currentIndex := 1
	found := false

	// Iterate to find the task at index
	// Note: We skip non-task lines but we must match the logic in listTasks
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "- [ ]") || strings.HasPrefix(trimmed, "- [x]") {
			if currentIndex == index {
				taskLine = trimmed
				found = true
				break
			}
			currentIndex++
		}
	}

	if !found {
		return fmt.Errorf("task #%d not found in %s", index, todoFile)
	}

	if strings.HasPrefix(taskLine, "- [x]") {
		fmt.Fprintf(cmd.OutOrStdout(), "Task #%d is already marked as done.\n", index)
		// We continue to allow re-solving if needed, as the user explicitly asked for it.
	}

	// 2. Parse Task Info
	// Format: "- [ ] [file:line] Keyword: Content"
	// Example: "- [ ] [cmd/recac/main.go:42] TODO: Fix bug"
	content := strings.TrimPrefix(taskLine, "- [ ] ")
	content = strings.TrimPrefix(content, "- [x] ")

	// Regex to extract file, line, and description
	// matches: [path:line] description
	// The path might contain anything but ':', line is digits.
	re := regexp.MustCompile(`^\[(.*?):(\d+)\]\s*(.*)$`)
	matches := re.FindStringSubmatch(content)

	if len(matches) < 4 {
		return fmt.Errorf("could not parse task location. Ensure it was generated by 'recac todo scan'.\nTask: %s", content)
	}

	filePath := matches[1]
	// lineNumStr := matches[2] // We might not strictly need the line number if we search, but helpful
	description := matches[3]

	// 3. Read Source File
	fileContent, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read source file %s: %w", filePath, err)
	}

	// 4. Initialize Agent
	ctx := context.Background()
	provider := viper.GetString("provider")
	model := viper.GetString("model")
	cwd, _ := os.Getwd()

	ag, err := agentClientFactory(ctx, provider, model, cwd, "recac-todo-solve")
	if err != nil {
		return fmt.Errorf("failed to create agent: %w", err)
	}

	// 5. Construct Prompt
	prompt := fmt.Sprintf(`You are an expert software engineer.
Your task is to implement the following TODO item in the provided file.
You must replace the TODO comment with the actual implementation code.
Do not change other parts of the file unnecessarily.

Task: %s
File: %s

Code:
`+"```"+`
%s
`+"```"+`

Return the FULL content of the modified file in a code block.`, description, filePath, string(fileContent))

	fmt.Fprintf(cmd.OutOrStdout(), "ðŸ¤– Solving task: %s\n", description)
	fmt.Fprintf(cmd.OutOrStdout(), "   File: %s\n", filePath)

	// 6. Call Agent
	response, err := ag.Send(ctx, prompt)
	if err != nil {
		return fmt.Errorf("agent failed: %w", err)
	}

	modifiedContent := utils.CleanCodeBlock(response)

	if len(modifiedContent) == 0 {
		return fmt.Errorf("received empty response from agent")
	}

	// 7. Write File
	if err := os.WriteFile(filePath, []byte(modifiedContent), 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", filePath, err)
	}
	fmt.Fprintf(cmd.OutOrStdout(), "âœ… Updated %s\n", filePath)

	// 8. Update TODO.md
	if err := toggleTaskStatus(index, true); err != nil {
		return fmt.Errorf("failed to mark task as done: %w", err)
	}
	fmt.Fprintf(cmd.OutOrStdout(), "âœ… Marked task #%d as done in %s\n", index, todoFile)

	return nil
}
